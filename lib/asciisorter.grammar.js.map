{
  "version": 3,
  "file": "asciisorter.grammar.js",
  "sourceRoot": "..",
  "sources": [
    "src/asciisorter.grammar.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "\n'use strict'\n\n############################################################################################################\nCND                       = require 'cnd'\nbadge                     = 'PARAGATE/GRAMMARS/ASCIISORTER'\nlog                       = CND.get_logger 'plain',     badge\ninfo                      = CND.get_logger 'info',      badge\nwhisper                   = CND.get_logger 'whisper',   badge\nalert                     = CND.get_logger 'alert',     badge\ndebug                     = CND.get_logger 'debug',     badge\nwarn                      = CND.get_logger 'warn',      badge\nhelp                      = CND.get_logger 'help',      badge\nurge                      = CND.get_logger 'urge',      badge\necho                      = CND.echo.bind CND\n#...........................................................................................................\n{ assign\n  jr }                    = CND\n# CHVTN                     = require 'chevrotain'\n{ lets\n  freeze }                = ( new ( require 'datom' ).Datom { dirty: false, } ).export()\ntypes                     = require './types'\n{ isa\n  type_of\n  validate }              = types\nGRAMMAR                   = require './grammar'\nINTERTEXT                 = require 'intertext'\n{ rpr }                   = INTERTEXT.export()\n\n#-----------------------------------------------------------------------------------------------------------\nnew_ref = ( this_ref, prv_ref ) ->\n  ### TAINT implement as optional functionality of `DATOM.new_datom()` ###\n  return ( this_ref + prv_ref ).replace /\\^+/g, '^'\n\n#-----------------------------------------------------------------------------------------------------------\ndd = ( d, ref = null ) ->\n  ### TAINT implement as optional functionality of `DATOM.new_datom()` ###\n  # debug '^3334^', ( rpr d ), ( rpr ref.$ ), ( rpr new_ref d, ref ) if ref?\n  d.$ = new_ref d.$, ref.$ if ref?.$?\n  for k of d\n    delete d[ k ] if d[ k ] in [ undefined, null, '', ]\n  return d\n\n#-----------------------------------------------------------------------------------------------------------\n### A function to perform matches; a matcher function may, but doesn't have to use regexes; if it does,\nit can use features not currently supported by Chevrotain (e.g. Unicode flag). Observe that in order to\navoid generating a new string for each character tested, we prefer to use the 'sticky flag' (`/.../y`)\nand set `lastIndex`. It is probably a good idea to define patterns outside of matcher functions for better\nperformance. ###\nmatch_ucletter = ( text, start ) ->\n  pattern           = /[A-Z]+/y\n  pattern.lastIndex = start\n  if ( match = text.match pattern )?\n    return [ match[ 0 ], ]\n  return null\n\n#-----------------------------------------------------------------------------------------------------------\n_match_catchall_with_function = ( matcher, text, start, last_idx ) ->\n  last_idx = Math.min text.length, last_idx\n  for idx in [ start ... last_idx ]\n    return idx if ( matcher text, idx )?\n  return null\n\n#-----------------------------------------------------------------------------------------------------------\nmatch_catchall = ( text, start ) ->\n  ###\n\n  xxx Assuming this token matcher has been put last, try all other token matchers for all positions starting\n  from the current, recording their matching index. From all indexes, find the smallest index, if any, and\n  return the text (wrapped in a list) between the current index and that minimal matching index, or else\n  `null`.\n\n  Optimizations:\n    * need only consider smallest index,\n    * so no need to build list of results,\n    * and no need for function matchers to be called after current best result.\n\n  ###\n  nearest = +Infinity\n  #.........................................................................................................\n  for _, { match: matcher, } of XXXX_LEXER_MODES.basic_mode\n    break if ( matcher is match_catchall ) ### stop here b/c this matcher must come last or act as if so ###\n    idx = null\n    #.......................................................................................................\n    switch type = type_of matcher\n      #.....................................................................................................\n      when 'regex'\n        my_matcher            = new RegExp matcher, 'g'\n        my_matcher.lastIndex  = start\n        continue unless ( match = my_matcher.exec text )?\n        idx = match.index\n      #.....................................................................................................\n      when 'function'\n        idx = _match_catchall_with_function matcher, text, start, nearest\n      else throw new Error \"^47478^ unknown matcher type #{rpr type}\"\n    #.......................................................................................................\n    if idx? and idx < nearest\n      nearest = idx\n  #.........................................................................................................\n  return [ text[ start ... nearest ] ] ### using `Infinity` for upper bound is OK ###\n\n#===========================================================================================================\n#\n#-----------------------------------------------------------------------------------------------------------\n@lexer_modes = XXXX_LEXER_MODES =\n  #.........................................................................................................\n  basic_mode:\n    T_lcletters:      { match: /[a-z]+/,          }\n    # custom patterns should explicitly specify the line_breaks property\n    T_ucletters:      { match: match_ucletter,  line_breaks: false, } ### match by function; used for advanced matching ###\n    T_newline:        { match: /\\n/,        }\n    T_digits:         { match: /[0-8]+/,        }\n    # lbrace:           { match: /[(\\[{]+/,       }\n    # rbrace:           { match: /[)\\]}]+/,       }\n    # quote:            { match: /['\"]+/,         }\n    T_sign:           { match: /[-+]/,          }\n    T_punctuation:    { match: /[=,.;:!?]+/,    }\n    T_spaces:         { match: /\\s+/,           }\n    T_catchalls:      { match: match_catchall, line_breaks: false, }\n\n#-----------------------------------------------------------------------------------------------------------\n### Minimal summarizer that could be generated where missing: ###\n@summarize = ( t, grammar ) ->\n  # debug '^33442^', rpr grammar.settings\n  @RULE 'document', =>\n    @MANY =>\n      @OR [\n        { ALT: => @SUBRULE @P_alphanumeric    }\n        { ALT: => @SUBRULE @P_number          }\n        { ALT: => @CONSUME t.T_lcletters      }\n        { ALT: => @CONSUME t.T_ucletters      }\n        { ALT: => @CONSUME t.T_newline        }\n        # { ALT: => @CONSUME t.T_digits         }\n        # { ALT: => @CONSUME t.lbrace           }\n        # { ALT: => @CONSUME t.rbrace           }\n        # { ALT: => @CONSUME t.quote            }\n        { ALT: => @CONSUME t.T_punctuation    }\n        { ALT: => @CONSUME t.T_spaces         }\n        { ALT: => @CONSUME t.T_sign           }\n        { ALT: => @CONSUME t.T_catchalls      }\n        ]\n  @RULE 'P_alphanumeric', =>\n    @OR [\n      { ALT: => @CONSUME t.T_lcletters        }\n      { ALT: => @CONSUME t.T_ucletters        }\n      ]\n    @CONSUME t.T_digits\n  @RULE 'P_number', =>\n    @OPTION => @CONSUME t.T_sign\n    @CONSUME t.T_digits\n\n#-----------------------------------------------------------------------------------------------------------\n@linearize = ( source, tree, level = 0 ) ->\n  return null unless tree?\n  #.........................................................................................................\n  { name: token_name\n    $key\n    start\n    stop\n    text\n    $vnr } = tree\n  #.........................................................................................................\n  if $key is '^token'\n    switch token_name\n      when 'T_lcletters' then yield dd { $key: '^text',   type: 'lower', start, stop, text, $vnr, $: '^α1^', }, tree\n      when 'T_ucletters' then yield dd { $key: '^text',   type: 'upper', start, stop, text, $vnr, $: '^α2^', }, tree\n      when 'T_digits'    then yield dd { $key: '^number',                start, stop, text, $vnr, $: '^α2^', }, tree\n      when 'T_catchalls' then yield dd { $key: '^text',   type: 'other', start, stop, text, $vnr, $: '^α3^', }, tree\n      else yield dd { $key: '^unknown', text, start, stop, $value: tree, $vnr, $: '^α4^', }, tree\n    return null\n  throw new Error \"^445^ unknown $key #{rpr $key}\" unless $key in [ '^document', '^node', ]\n  #.........................................................................................................\n  { ukids } = tree\n  ### NOTE we assume that unique kids exist and that values are stored in source order ###\n  for _, ukid of ukids\n    $vnr = ukid.$vnr\n    break\n  #.........................................................................................................\n  if $key is '^document'\n    yield dd { $key: '<document', start: 0, stop: 0, source, errors: tree.errors, $vnr: [ -Infinity, ], $: '^α5^', }\n    for subtree in tree.kids\n      yield from @linearize source, subtree, level + 1\n    x = text.length\n    yield dd { $key: '>document', start: x, stop: x, $vnr: [ Infinity, ], $: '^α6^', }\n    return null\n  #.........................................................................................................\n  debug '^3332^', ( rpr token_name ), ( rpr tree )\n  switch token_name\n    #.......................................................................................................\n    when 'P_alphanumeric'\n      $key = '^alphanumeric'\n      if      tree.ukids.T_lcletters?       then type = 'lower'\n      else if tree.ukids.T_ucletters?       then type = 'upper'\n      yield dd { $key, type, text, start, stop, $vnr, $: '^α7^', }\n    #.......................................................................................................\n    when 'P_number'\n      $key  = '^number'\n      type  = switch tree.ukids.T_sign.text ? '+'\n        when '+' then 'positive'\n        when '-' then 'negative'\n      yield dd { $key, type, text, start, stop, type, $vnr, $: '^α7^', }\n    #.......................................................................................................\n    else yield dd { $key: '^unknown', text, start, stop, $value: tree, $vnr, $: '^α8^', }\n  return null\n\n\n#===========================================================================================================\n#\n#-----------------------------------------------------------------------------------------------------------\nASCIISORTER = @\nclass Asciisorter extends GRAMMAR.Grammar\n  constructor: ( settings = null ) ->\n    settings  = assign { use_summarize: true, }, settings\n    name      = if settings.use_summarize then 'asciisorter' else 'asciiautosumm'\n    super name, ASCIISORTER, settings\n    unless @settings.use_summarize\n      delete @linearize\n      delete @summarize\n      @parser = @_new_parser name\n    return @\n\nasciisorter = new Asciisorter()\nmodule.exports = { asciisorter, Asciisorter, }\n\n\n\n\n"
  ]
}