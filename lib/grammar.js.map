{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "/home/flow/jzr/paragate/src/grammar.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "\n'use strict'\n\n############################################################################################################\nCND                       = require 'cnd'\nrpr                       = CND.rpr\nbadge                     = 'PARAGATE/GRAMMARS/GRAMMAR'\nlog                       = CND.get_logger 'plain',     badge\ninfo                      = CND.get_logger 'info',      badge\nwhisper                   = CND.get_logger 'whisper',   badge\nalert                     = CND.get_logger 'alert',     badge\ndebug                     = CND.get_logger 'debug',     badge\nwarn                      = CND.get_logger 'warn',      badge\nhelp                      = CND.get_logger 'help',      badge\nurge                      = CND.get_logger 'urge',      badge\necho                      = CND.echo.bind CND\n#...........................................................................................................\n{ assign\n  jr }                    = CND\nCHVTN                     = require 'chevrotain'\nDATOM                     = new ( require 'datom' ).Datom { dirty: false, }\n{ lets\n  freeze }                = DATOM.export()\ntypes                     = require './types'\n{ isa\n  validate\n  type_of }               = types\nMultimix                  = require 'multimix'\nMAIN                      = @\nis_given                  = ( x ) -> not [ null, undefined, NaN, '', ].includes x\n#-----------------------------------------------------------------------------------------------------------\n### thx to https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name ###\nset_class_name            = ( clasz, name ) -> Object.defineProperty clasz, 'name', { value: name, writable: false, }\n\n#-----------------------------------------------------------------------------------------------------------\nnew_ref = ( d, $ ) ->\n  if ( ref = d.$ )?\n    ref = ref[ 1 .. ] while ref.startsWith '^'\n    $  += ref\n  return $\n\n#===========================================================================================================\n# PARSING & LINEARIZATION\n#-----------------------------------------------------------------------------------------------------------\n@on_before_tokenize = ( source      ) -> source\n@on_before_parse    = ( raw_tokens  ) -> raw_tokens\n@on_after_parse     = ( ds          ) -> ds\n\n#-----------------------------------------------------------------------------------------------------------\n@parse = ( source ) ->\n  @source = source\n  #.........................................................................................................\n  ### TAINT re-introduce possibility to choose lexer mode ###\n  source                  = ( @on_before_tokenize source ) ? source\n  tokenization            = @lexer.tokenize source # @settings.lexer_mode\n  lexer_errors            = @_adapt_lexer_errors source, tokenization\n  for _, group of tokenization.groups\n    for token in group\n      token.$vnr  = [ token.startLine, token.startColumn, ]\n      token.$     = new_ref token, '^Γ1^'\n  for token in tokenization.tokens\n    token.$vnr  = [ token.startLine, token.startColumn, ]\n    token.$     = new_ref token, '^Γ2^'\n  #.........................................................................................................\n  @parser.input     = ( @on_before_parse tokenization.tokens, tokenization.groups ) ? tokenization.tokens\n  cst               = @parser[ @settings.parser_start ]()\n  tree              = @_adapt_tree source, cst\n  errors            = { lexer: tokenization.errors, parser: @parser.errors, }\n  parser_errors     = @_adapt_parser_errors source, errors.parser\n  errors            = lexer_errors.concat parser_errors\n  tree              = lets tree, ( tree ) -> tree.errors = errors\n  datoms            = @linearize source, tree\n  R                 = [ datoms..., errors..., ]\n  R                 = ( @on_after_parse R ) ? R\n  return freeze @_sort_nodes R\n\n#-----------------------------------------------------------------------------------------------------------\n@_sort_nodes = ( nodes ) ->\n  ### R.sort ( a, b ) -> according to DATOM/VNR fair sorting ###\n  return nodes.sort ( a, b ) ->\n    a = a.$vnr ? [ a.start ? -Infinity, a.stop ? -Infinity, ]\n    b = b.$vnr ? [ b.start ? -Infinity, b.stop ? -Infinity, ]\n    DATOM.VNR.cmp_fair a, b\n\n#-----------------------------------------------------------------------------------------------------------\n@linearize = ( source, tree, level = 0 ) ->\n  ### In most cases to be overridden by client grammar. ###\n  { $key\n    name\n    start\n    stop\n    text } = tree\n  #.........................................................................................................\n  switch $key\n    #.......................................................................................................\n    when '^token' then yield tree\n    #.......................................................................................................\n    when '^document'\n      yield { $key: '<document', name, start, stop, text, $vnr: [ -Infinity, ], $: ( new_ref tree, '^Γ4^' ), }\n      for kid in tree.kids\n        yield from @linearize source, kid, level + 1\n      yield { $key: '>document', name, start: stop, stop, $vnr: [ +Infinity, ], $: ( new_ref tree, '^Γ6^' ), }\n    #.......................................................................................................\n    when '^node'\n      $vnr = tree.kids[ 0 ]?.$vnr ? null\n      if $vnr? then yield { $key: '^node', name, start, stop, text, $vnr, $: ( new_ref tree, '^Γ9^' ), }\n      else          yield { $key: '^node', name, start, stop, text,       $: ( new_ref tree, '^Γ10^' ), }\n    #.......................................................................................................\n    else throw new Error \"^445^ unknown $key #{rpr $key}\" unless $key is '^node'\n  #.........................................................................................................\n  return null\n\n\n#===========================================================================================================\n#\n#-----------------------------------------------------------------------------------------------------------\n@_adapt_tree = ( source, cst ) ->\n  unless cst?\n    $key  = '^node'\n    name  = 'document'\n    text  = source\n    ### TAINT add VNR ###\n    return freeze { $key, name, kids: [], start: 0, stop: source.length, text, $: '^Γ13^', }\n  R = @_adapt_tree_inner source, cst\n  if R.$key is '^node' and R.name is 'document'\n    R.$key = '^document'\n    delete R.name\n  return freeze R\n\n#-----------------------------------------------------------------------------------------------------------\n@_adapt_tree_inner = ( source, tree ) ->\n  R = datom_from_token tree\n  return R unless tree.children?\n  #.........................................................................................................\n  R.kids    = []\n  R.kidkeys = new Set()\n  R.ukids   = {} # **u**nique **kids**\n  for key, tokens of tree.children\n    R.kidkeys.add key\n    for token in tokens\n      R.kids.push kid = @_adapt_tree_inner source, token\n    if tokens.length is 1\n      R.ukids[ key ] = kid\n  R.kids.sort ( a, b ) -> a.start - b.start\n  R.start   = R.kids[ 0                   ]?.start  ? -1\n  R.stop    = R.kids[ R.kids?.length - 1  ]?.stop   ? -1\n  R.text    = source[ R.start ... R.stop ]\n  R.kidkeys = [ R.kidkeys..., ]\n  return R\n\n\n#===========================================================================================================\n# ERROR TREATMENT\n#-----------------------------------------------------------------------------------------------------------\n@_adapt_lexer_errors = ( source, tokenization ) ->\n  R       = []\n  origin  = 'lexer'\n  $key    = '^error'\n  for error in tokenization.errors\n    { offset\n      length\n      message\n      line\n      column  } = error\n    start       = offset\n    stop        = offset + length\n    text        = source[ start ... stop ]\n    $vnr        = if ( is_given line ) and ( is_given column ) then [ line, column, ] else null\n    if message.startsWith 'extraneous' then code = 'extraneous'\n    else                                    code = 'other'\n    if $vnr? then R.push { $key, code, origin, message, text, start, stop, $vnr, $: '^Γ14^', }\n    else          R.push { $key, code, origin, message, text, start, stop,       $: '^Γ15^', }\n  return R\n\n#-----------------------------------------------------------------------------------------------------------\nvnr_from_parser_error = ( error ) ->\n  R = null\n  for key in [ 'token', 'previousToken', ]\n    token = error[ key ]\n    break if ( R = token?.$vnr )?\n    if ( is_given linenr = token.startLine ) and ( is_given colnr = token.startColumn )\n      R = [ linenr, colnr, ]\n      break\n  return R\n\n#-----------------------------------------------------------------------------------------------------------\n@_adapt_parser_errors = ( source, errors ) ->\n  R           = []\n  origin      = 'parser'\n  $key        = '^error'\n  for error in errors\n    ### TAINT use `error.resyncedTokens`??? ###\n    { name: chvtname\n      message         } = error\n    $vnr                = vnr_from_parser_error error\n    ### TAINT code duplication ###\n    text                = error.token.image\n    start               = error.token.startOffset\n    stop                = start + ( text?.length ? start )\n    #.......................................................................................................\n    switch chvtname\n      when 'NotAllInputParsedException' then  code = 'extraneous'\n      when 'MismatchedTokenException'   then  code = 'mismatch'\n      when 'NoViableAltException'       then  code = 'missing'\n      else                                    code = 'other'\n    text    = error.previousToken.image               if isa.not_given text\n    start   = error.previousToken.startOffset         if isa.not_given start\n    ### TAINT code duplication ###\n    start   = 0                                       if isa.not_given start\n    stop    = start + ( text?.length ? 0 )            if isa.not_given stop\n    text    = source[ start ... stop ]  if isa.not_given text\n    if $vnr? then R.push { $key, code, chvtname, origin, message, text, start, stop, $vnr,  $: '^Γ16^', }\n    else          R.push { $key, code, chvtname, origin, message, text, start, stop,        $: '^Γ17^', }\n  return R\n\n# #-----------------------------------------------------------------------------------------------------------\n# @_all_children_of_token = ( token ) ->\n#   ### TAINT make generally accessible to grammar? ###\n#   ### TAINT tokens in groups might be missing??? ###\n#   return [] unless ( c = token.children )?\n#   return ( ts for _, ts of c ).flat Infinity\n\n\n#===========================================================================================================\n#\n#-----------------------------------------------------------------------------------------------------------\n@_walk_tokendefs = ->\n  if ( type_of @lexer.lexerDefinition ) is 'list'\n    yield from @lexer.lexerDefinition\n    return null\n  for _, tokendefs of @lexer.lexerDefinition.modes\n    yield from tokendefs\n  return null\n\n#-----------------------------------------------------------------------------------------------------------\n@_token_map_from_lexer = ->\n  ### Helper function so we can accept a `Lexer` instance to instantiate a parser. ###\n  R                   = {}\n  R[ tokendef.name ]  = tokendef for tokendef from @_walk_tokendefs()\n  return R\n\n#-----------------------------------------------------------------------------------------------------------\ndatom_from_token = ( token ) ->\n  text  = token.image\n  start = token.startOffset\n  stop  = start + ( text?.length ? 0 )\n  $vnr  = null\n  $     = '^Γ18^'\n  if token.$vnr?\n    $     = '^Γ19^'\n    $vnr  = token.$vnr\n  else if ( is_given line = token.startLine ) and ( is_given column = token.startColumn )\n    $     = '^Γ20^'\n    $vnr = [ line, column, ]\n  $ = new_ref token, $\n  if ( name = token.tokenType?.name )?\n    $key = '^token'\n  else\n    $key = '^node'\n    name = token.name ? '???'\n  return { $key, name, text, start, stop, $vnr, $, } if $vnr?\n  return { $key, name, text, start, stop,       $, }\n\n\n#===========================================================================================================\n# LEXER, PARSER, GRAMMAR\n#-----------------------------------------------------------------------------------------------------------\n@_get_lexer_definition = ->\n  modes             = {}\n  R                 = { defaultMode: null, modes, }\n  #.........................................................................................................\n  for mode_name, mode of @lexer_modes\n    R.defaultMode      ?= mode_name\n    modes[ mode_name ]  = target  = []\n    ### TAINT validate ###\n    #.......................................................................................................\n    for token_name, description of mode\n      description.match = ( -> null ) if description.match is null\n      validate.paragate_parsers_lexer_token_description description\n      target.push new_token token_name, description\n  #.........................................................................................................\n  return R\n\n#-----------------------------------------------------------------------------------------------------------\nnew_token = ( name, description ) ->\n  ### TAINT should set `line_breaks` automatically where required by Chevrotain ###\n  settings                = {}\n  settings.name           = name\n  settings.pattern        = description.match\n  settings.switch_mode    = description.switch_mode if description.switch_mode?\n  settings.pop_mode       = description.pop_mode    if description.pop_mode?\n  settings.push_mode      = description.push_mode   if description.push_mode?\n  settings.group          = description.group       if description.group?\n  settings.skip           = description.skip        if description.skip?\n  settings.line_breaks    = description.line_breaks if description.line_breaks?\n  ### TAINT validate ###\n  if ( switch_mode = settings.switch_mode )?\n    delete settings.switch_mode\n    settings.pop_mode   = true\n    settings.push_mode  = switch_mode\n  if settings.skip\n    delete settings.skip\n    if settings.group?\n      throw new Error \"^3382^ can only set one of `skip`, `group`; got #{rpr settings.skip}, #{rpr settings.group}\"\n    settings.group = CHVTN.Lexer.SKIPPED\n  return CHVTN.createToken settings\n\n#-----------------------------------------------------------------------------------------------------------\n@_new_lexer = ( name ) ->\n  #.........................................................................................................\n  unless @description?\n    return R if ( R = @settings.lexer )?\n    throw new Error \"^730274^ must give either `lexer_modes` in description or provide `lexer` setting\"\n  #.........................................................................................................\n  settings =\n    positionTracking:           'full',\n    ensureOptimizations:        false\n    lineTerminatorCharacters:   [ '\\n', ],\n    lineTerminatorsPattern:     /\\n/g,\n    errorMessageProvider:\n      buildUnexpectedCharactersMessage: ( source, start, length, line, column ) ->\n        ### see https://sap.github.io/chevrotain/docs/features/custom_errors.html ###\n        text = source[ start ... start + length ]\n        return \"extraneous characters on line #{line ? '?'} column #{column ? '?'}: #{jr text}\"\n  #.........................................................................................................\n  class R extends CHVTN.Lexer\n  #.........................................................................................................\n  set_class_name R, \"#{name}_lexer\"\n  lexer_definition = @_get_lexer_definition()\n  return new R lexer_definition, settings\n\n#-----------------------------------------------------------------------------------------------------------\n@_generate_summarizer = ->\n  alternatives = []\n  for tokendef from @_walk_tokendefs()\n    do ( tokendef ) ->\n      alternatives.push { ALT: -> @CONSUME tokendef }\n  @summarize = ( t ) ->\n    @RULE 'document', ->\n      @MANY ->\n        @OR alternatives\n  return null\n\n#-----------------------------------------------------------------------------------------------------------\n@_new_parser = ( name ) ->\n  @_generate_summarizer() unless @summarize?\n  grammar = @\n  #.........................................................................................................\n  class R extends CHVTN.CstParser\n    #.......................................................................................................\n    constructor: ( lexer ) ->\n      ### TAINT validate lexer ###\n      tokensMap = grammar._token_map_from_lexer()\n      super tokensMap, { nodeLocationTracking: 'full', recoveryEnabled: true, }\n      @setup @tokensMap\n      return @\n    #.......................................................................................................\n    setup: ( t ) ->\n      grammar.summarize.call @, t, grammar\n      @performSelfAnalysis()\n    #.......................................................................................................\n    RULE: ( rule_name, P... ) ->\n      grammar.settings.parser_start ?= rule_name\n      return super rule_name, P...\n  #.........................................................................................................\n  set_class_name R, \"#{name}_parser\"\n  return new R grammar.lexer\n\n#-----------------------------------------------------------------------------------------------------------\nclass Grammar extends Multimix\n  @include MAIN,        { overwrite: false, }\n\n  #---------------------------------------------------------------------------------------------------------\n  constructor: ( name, description, settings = null ) ->\n    super()\n    validate.nonempty_text name\n    # validate.paragate_grammar_description  description\n    # validate.paragate_grammar_settings     settings\n    defaults        = { parser_start: null, }\n    @name           = name\n    @description    = description\n    @settings       = { defaults..., settings..., }\n    @source         = null\n    #.......................................................................................................\n    ### TAINT use Multimix method? property descriptors? ###\n    if description?\n      @[ k ] = v for k, v of description\n    #.......................................................................................................\n    @lexer          = @_new_lexer   name\n    @parser         = @_new_parser  name\n    return @\n\n#-----------------------------------------------------------------------------------------------------------\nnew_grammar = ( name, description, settings = null ) ->\n  ### Same as `new Grammar name, description, settings` except that the returned instance's class name\n  will be `${name}_grammar`; commonly used by grammars as shortcut to instantiate grammar without having\n  to declare a derived class. ###\n  class R extends Grammar\n  set_class_name R, \"#{name}_grammar\"\n  return new R name, description, settings\n\n\n############################################################################################################\nmodule.exports = { Grammar, new_grammar, }\n\n\n\n\n\n"
  ]
}