{
  "version": 3,
  "file": "indentation.grammar.js",
  "sourceRoot": "..",
  "sources": [
    "src/indentation.grammar.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "\n'use strict'\n\n############################################################################################################\nCND                       = require 'cnd'\nbadge                     = 'INTERTEXT/GRAMMARS/INDENTATION'\nlog                       = CND.get_logger 'plain',     badge\ninfo                      = CND.get_logger 'info',      badge\nwhisper                   = CND.get_logger 'whisper',   badge\nalert                     = CND.get_logger 'alert',     badge\ndebug                     = CND.get_logger 'debug',     badge\nwarn                      = CND.get_logger 'warn',      badge\nhelp                      = CND.get_logger 'help',      badge\nurge                      = CND.get_logger 'urge',      badge\necho                      = CND.echo.bind CND\n#...........................................................................................................\n{ assign\n  jr }                    = CND\n# CHVTN                     = require 'chevrotain'\n{ lets\n  freeze }                = ( new ( require 'datom' ).Datom { dirty: false, } ).export()\ntypes                     = require './types'\n{ isa\n  type_of\n  validate }              = types\nGRAMMAR                   = require './grammar'\nINTERTEXT                 = require 'intertext'\n{ rpr }                   = INTERTEXT.export()\nspace_re                  = /\\x20+/y\n\n\n\n\n###\n This example demonstrate implementing a lexer for a language using python style indentation.\n This is achieved by using custom Token patterns which allow running user defined logic\n to match tokens.\n\n The logic is simple:\n - Indentation tokens (indent, dedent) can only be created for whitespace on the beginning of a line.\n - Change in the 'level' of the indentation will create either indent(increase) or dedent(decrease).\n - Same indentation level will be parsed as 'regular' whitespace and be ignored.\n - To implement this the previous Ident levels will be saved in a stack.\n\n For additional details on custom token patterns, see the docs:\n https://github.com/SAP/chevrotain/blob/master/docs/custom_token_patterns.md\n\n\n###\n\n{ createToken\n  createTokenInstance\n  Lexer }                 = require 'chevrotain'\n\n# State required for matching the indentations\nindent_stack = [ 0, ]\n\n#-----------------------------------------------------------------------------------------------------------\nis_empty      = ( x     ) -> x.length is 0\nlast_of       = ( x     ) -> x[ x.length - 1 ]\nstart_of_last = ( x     ) -> x[ x.length - 1 ].startOffset\nin_this_order = ( x, y  ) -> ( start_of_last x ) < ( start_of_last y )\n\n#-----------------------------------------------------------------------------------------------------------\nfind_last_index = ( list, predicate ) ->\n  ### Copy of Lodash `findLastIndex()` ###\n  R = list.length\n  loop\n    R--\n    return R if predicate list[ R ]\n  return R\n\n#-----------------------------------------------------------------------------------------------------------\nvnr_from_text_and_position = ( text, position ) ->\n  ### TAINT coordinates use code units, not code points, so columns may be off in the presence of 32bit\n  characters. ###\n  lines       = text[ ... position ].split '\\n'\n  line_count  = lines.length\n  return [ line_count, lines[ line_count - 1 ].length + 1, ]\n\n#-----------------------------------------------------------------------------------------------------------\nmatch_leading_ws = ( text, start, matched_tokens, groups, type ) ->\n  ### This custom Token matcher uses Lexer context ('matched_tokens' and 'groups' arguments) combined with\n  state via closure ('indent_stack' and 'lastTextMatched') to match indentation.\n\n  @param {string} text - the full text to lex, sent by the Chevrotain lexer.\n  @param {number} start - the offset (index) to start matching in the text.\n  @param {IToken[]} matched_tokens - Tokens lexed so far, sent by the Chevrotain Lexer.\n  @param {object} groups - Token groups already lexed, sent by the Chevrotain Lexer.\n  @param {string} type - determines if this function matches indent or dedent tokens.\n  @returns {*} ###\n  # whisper '^119822^1', '------------------------------------------------'\n  # urge '^119822-2^', \"indent_stack\", rpr indent_stack\n  #.........................................................................................................\n  nls                   = groups.nl\n  no_matched_nls        = is_empty nls\n  no_matched_tokens     = is_empty matched_tokens\n  has_matched_nls       = not no_matched_nls\n  has_matched_tokens    = not no_matched_tokens\n  #.........................................................................................................\n  only_nls_so_far       = no_matched_tokens and has_matched_nls\n  has_matched_both      = has_matched_tokens and has_matched_nls\n  is_first_line         = no_matched_tokens and no_matched_nls\n  is_start_of_line      = only_nls_so_far or has_matched_both and in_this_order matched_tokens, nls\n  #.........................................................................................................\n  # indentation can only be matched at the start of a line.\n  if ( is_first_line or is_start_of_line )\n    match               = null\n    level_now           = null\n    level_prv           = last_of indent_stack\n    space_re.lastIndex  = start\n    match               = space_re.exec text\n    #.......................................................................................................\n    if match? then  level_now = match[ 0 ].length\n    else            level_now = 0\n    #.......................................................................................................\n    # deeper indentation\n    if ( level_now > level_prv ) and ( type is 'indent' )\n      indent_stack.push level_now\n      return match\n    #.......................................................................................................\n    # shallower indentation\n    if ( level_now < level_prv ) and ( type is 'outdent' )\n      mirror_idx = find_last_index indent_stack, ( space_count ) => space_count is level_now\n      # any outdent must match some previous indentation level.\n      if ( mirror_idx is -1 )\n        throw new Error \"invalid outdent at start: ${start}\"\n      dedent_count = indent_stack.length - mirror_idx - 1\n      #.....................................................................................................\n      # This is a little tricky\n      # 1. If there is no match (0 level indent) than this custom token\n      #    matcher would return 'null' and so we need to add all the required outdents ourselves.\n      # 2. If there was match (> 0 level indent) than we need to add minus one number of outsents\n      #    because the lexer would create one due to returning a none null result.\n      counter_start = if match? then 1 else 0\n      for _ in [ counter_start ... dedent_count ]\n        # info '^119822-3^', \"pop\", rpr indent_stack\n        indent_stack.pop()\n        # info '^119822-4^', \"pop\", rpr indent_stack\n        $vnr = vnr_from_text_and_position text, start\n        dedent_token = createTokenInstance dedent, '', start, start, $vnr[ 0 ], null, $vnr[ 1 ]\n        dedent_token.$vnr = $vnr\n        dedent_token.$    = '^i1^'\n        matched_tokens.push dedent_token\n      #.....................................................................................................\n      # even though we are adding fewer outdents directly we still need to update the indent stack fully.\n      # info '^119822-5^', \"pop\", rpr indent_stack\n      indent_stack.pop() if counter_start is 1\n      # info '^119822-6^', \"pop\", rpr indent_stack\n      # debug '^119822-7^', \"indent_stack\", rpr indent_stack\n      return match\n    # same indent, this should be lexed as simple whitespace and ignored\n    # debug '^119822-8^', \"indent_stack\", rpr indent_stack\n    return null\n  # indentation cannot be matched under other circumstances\n  # debug '^119822-9^', \"indent_stack\", rpr indent_stack\n  return null\n\n#-----------------------------------------------------------------------------------------------------------\nmatch_indent  = ( text, start, matched_tokens, groups ) -> match_leading_ws text, start, matched_tokens, groups, 'indent'\nmatch_dedent  = ( text, start, matched_tokens, groups ) -> match_leading_ws text, start, matched_tokens, groups, 'outdent'\n\n# #-----------------------------------------------------------------------------------------------------------\n# match_blank = ( text, start, matched_tokens, groups ) ->\n#   debug '^334^', rpr ( ( t.tokenType?.name ? '???' ) for t in matched_tokens )\n#   debug '^334^', rpr ( ( t.tokenType?.name ? '???' ) for t in groups.nl )\n#   debug '^334^', rpr ( ( t.image ? '???' ) for t in groups.nl )\n#   ### TAINT WIP ###\n#   #^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n#   # info '^119822-3^', \"match\", rpr match\n#   xxx_pattern           = /(?<blank>\\x20*)(?=\\n|$)/y\n#   xxx_pattern.lastIndex = start\n#   if ( match = text.match xxx_pattern )?\n#     info '^119822-3^', \"blank\", rpr match\n#     # text  = match.groups.blank\n#     # stop  = start + text.length\n#     # ( groups.nl ?= [] ).push createTokenInstance blank, text, start, stop\n#     # return match\n#   return null\n\n#-----------------------------------------------------------------------------------------------------------\n# indentation tokens must appear before Spaces, otherwise all indentation will always be consumed as spaces.\n# dedent must appear before indent for handling zero spaces outdents.\n# By setting group of newlines to \"nl\" they are saved in the lexer result\n# and thus we can check before creating an indentation token that the last token matched was a newline.\ntoken_defs = [\n  # blank   = createToken { name: 'blank',    pattern: match_blank, }\n  newline = createToken { name: 'T_newline',  pattern: /\\n|\\r\\n?/, group: 'nl', }\n  dedent  = createToken { name: 'T_dedent',   pattern: match_dedent,  line_breaks: false, }\n  indent  = createToken { name: 'T_indent',   pattern: match_indent,  line_breaks: false, }\n  line    = createToken { name: 'T_line',     pattern: /[^\\n]+/, }\n  ]\n\n#-----------------------------------------------------------------------------------------------------------\nindentation_lexer = new Lexer token_defs, { positionTracking: 'full', ensureOptimizations: false, }\n\n\n# #-----------------------------------------------------------------------------------------------------------\n# @summarize = ( t, grammar ) ->\n#   #---------------------------------------------------------------------------------------------------------\n#   @RULE 'document', =>\n#     @MANY =>\n#       @OR [\n#         # { ALT: => @SUBRULE @indent_line_and_nl  }\n#         # { ALT: => @SUBRULE @line_and_nl  }\n#         # { ALT: => @CONSUME t.newline  }\n#         # { ALT: => @CONSUME t.dedent  }\n#         # { ALT: => @CONSUME t.indent   }\n#         # { ALT: => @CONSUME t.line     }\n#         # { ALT: => @SUBRULE @P_indent_line_and_nl }\n#         # { ALT: => @SUBRULE @P_line_and_nl        }\n#         { ALT: => @SUBRULE @P_newline            }\n#         { ALT: => @SUBRULE @P_dedent             }\n#         { ALT: => @SUBRULE @P_indent             }\n#         { ALT: => @SUBRULE @P_line               }\n#         ]\n#   #---------------------------------------------------------------------------------------------------------\n#   @RULE 'P_indent_line_and_nl', =>\n#     @CONSUME t.T_indent\n#     @CONSUME t.T_line\n#     @CONSUME t.T_newline\n#   #---------------------------------------------------------------------------------------------------------\n#   @RULE 'P_line_and_nl', =>\n#     @CONSUME t.T_line\n#     @CONSUME t.T_newline\n#   #---------------------------------------------------------------------------------------------------------\n#   @RULE 'P_newline',  => @CONSUME t.T_newline\n#   @RULE 'P_dedent',   => @CONSUME t.T_dedent\n#   @RULE 'P_indent',   => @CONSUME t.T_indent\n#   @RULE 'P_line',     => @CONSUME t.T_line\n#   return null\n\n#-----------------------------------------------------------------------------------------------------------\n### TAINT inplement in `datom/vnr` ###\nXXX_DATOM_VNR_append = ( d, nr ) ->\n  # validate.vnr d if @settings.validate\n  return [ d..., nr, ]\n\n#-----------------------------------------------------------------------------------------------------------\n@linearize = ( source, tree, level = 0 ) ->\n  # R = [ ( @get_my_prototype().linearize source, tree, level )..., ]\n  # if level is 0\n  #   for kid in tree.kids\n  #     debug '^220998^', rpr kid\n  for d from @get_my_prototype().linearize source, tree, level\n    # debug '^387^', rpr d\n    yield d\n  position  = @source.length\n  nr        = 0\n  while indent_stack.length > 1\n    indent_stack.pop()\n    nr++\n    $vnr = [ +Infinity, -nr, ]\n    yield { $key: '^token', name: 'T_dedent', start: position, stop: position, text: '', $vnr, $: '^i4^', }\n  return null\n\n#-----------------------------------------------------------------------------------------------------------\nsort_chevrotain_tokens = ( tokens ) ->\n  ### TAINT use VNR to sort ###\n  tokens.sort ( a, b ) ->\n    return a.endOffset - b.endOffset if ( a.startOffset is b.startOffset )\n    return a.startOffset - b.startOffset\n  return tokens\n\n\n#===========================================================================================================\n#\n#-----------------------------------------------------------------------------------------------------------\nMAIN = @\nclass Indention_grammar extends GRAMMAR.Grammar\n  @include MAIN, { overwrite: true, }\n\n  #---------------------------------------------------------------------------------------------------------\n  constructor: ( settings = null ) ->\n    super 'indentation_grammar', null, { lexer: indentation_lexer, }\n    return @\n\n  #---------------------------------------------------------------------------------------------------------\n  on_before_tokenize:  ( raw_tokens ) ->\n    indent_stack.length = 1\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  on_before_parse: ( tokens, groups ) ->\n    ### TAINT maybe provide API to merge tokens with groups ###\n    tokens.splice tokens.length, 0, groups.nl...\n    sort_chevrotain_tokens tokens\n    return tokens\n\nindentation_grammar = new Indention_grammar()\nmodule.exports      = { indentation_grammar, Indention_grammar, }\n\n\n\n\n\n\n\n"
  ]
}